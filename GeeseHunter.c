#pragma config(Sensor, S1,     ,               sensorTouch)
#pragma config(Sensor, S2,     ,               sensorTouch)
#pragma config(Sensor, S3,     ,               sensorSoundDB)
#pragma config(Sensor, S4,     ,               sensorSONAR)
//Code automatically generated by 'ROBOTC' configuration wizard

float offset(float Dist){/*This function calculates x offset for finding
	centre of x-axis, Written by Alexander Dipaola*/
		if(Dist>100)
			return  0;
		else
			return  Dist*.3;
}

void x_finder( int &x1, int &x2, int &flag_Maxrotation, float &Dist){/*Finds the horizontal
	coordinates of the goose. Written by Alexander Dipaola */
	int flag_angle=0;
	while (1) {/* */
			motor[motorA] = 10;
			if (SensorValue[S4]<=250 && SensorValue[S4]>=5 && flag_angle!=1){/* to recognize the left
				coordinate of the goose */
				x1 = nMotorEncoder[motorA];/* saves the value of the encoder for left side */
				Dist = SensorValue[S4];
				flag_angle=1;/* a flag to be able to recognize if the left side was found for future if statements */
				}
			if (flag_angle==1){/* if the left side was found */
				while (SensorValue[S4]<250){}/* looking for the object to end */
				x2= nMotorEncoder[motorA];/* saves the value of the encoder for the right side  */
				motor[motorA] = 0;
				break;/* breaks out of the loop because it saved both horizontal coordinates that are needed */
				}
			if (nMotorEncoder[motorA]>=1452 && flag_angle==1){/* for a situation where the left side of the goose is found
				but can't continue to find the right side due to the robot's maximum rotational capabilities*/
				x2= nMotorEncoder[motorA];/* the right end of the goose will be the maximum angle allowable for encoder */
				motor[motorA]=0;
				break;
				}
			if (nMotorEncoder[motorA]>=1452){/* if it doesn't find anything and runs out of the maximum angle allowable */
				flag_Maxrotation=1;/* flag rotation becomes 1 to indicate that nothing was found */
				motor[motorA]=0;
				break;
				}
		}
}

void x_center(int x1, int x2, int Dist){/* To find the horizontal midpoint of the goose. Written by Michael Lizewski */
	nMotorEncoder[motorA]=0;
	float offset_x = offset(Dist);/* using the offset function created earlier */
	float center_x = -((x2-x1)/2.0)	- offset_x;/*find the middle and adds offset to centre
	if it met the conditions */
	while (nMotorEncoder[motorA]>center_x){/* motor runs until it reaches the desired encoder value */
		motor[motorA] = -20;
	}
	motor[motorA] = 0;/* motor stops at the midpoint */
}


void y_finder (int &y1, int &y2, int y2_encoder){/* finds the vertical coordinates of the goose. Written by Justin Swinoga */
	motor[motorB]=25;
		while ( SensorValue[S4]<=250 && SensorValue[S4]>=5 && nMotorEncoder[motorB]<=800){}/* to find the top coordinate
		of the goose. 20 degrees is the maximum angle
		we can achieve. 20 degrees from horizon was put into the parametric equation of the spiral to obtain 800 rotation
		for motor B. */
	y1=nMotorEncoder[motorB];
	motor[motorB]=0;
	nMotorEncoder[motorB]=0;
	wait1Msec(1000);
		while ( SensorValue[S4]>=250 || SensorValue[S4]<=5){/* comes down until it sees the top part of the goose again */
			motor[motorB]=-20;}
		while ( SensorValue[S4]<=250 && SensorValue[S4]>=5 && SensorValue[S1]==0){}/* continues to come down until the goose
		can not be seen anymore*/
	y2_encoder=nMotorEncoder[motorB];/* saves the encoder value of motor that was lowered from the top coordinate*/
	motor[motorB]=0;
	y2= y1+(y2_encoder);/* find the vertical endpoint of the goose */
	nMotorEncoder[motorB]=0;}


void y_center(int y1, int y2, int &sweep){/* Written by Justin Swinoga */
	if (sweep==0){/* If on the first sweep,  */
		float y1_angle= (180.0/PI)*acos((1600.0*pow(2.718,29*y1/12750)-102485)/-100716.0);/* encoder value is input to find
		the actualy angle the top coordinate makes with horizontal*/
		float y2_angle=0;
		if (y2 > 45){/* the parametric function starts at 45 so any encoder value lower than that is not defined */
	 		y2_angle= (180.0/PI)*acos((1600.0*pow(2.718,29*y2/12750)-102485.0)/-100716.0);}
		float y_mid_angle = (y1_angle+y2_angle)/2;/* midpoint angle */
		int y_mid = 2.5*(5000/29)*2.55*log( (102485-100716*cosDegrees(y_mid_angle))/1600 );/* turning midpoint angle
		into encoder value*/
		while (nMotorEncoder[motorB]<=y_mid){/* going up until it reaches the midpoint */
			motor[motorB]=20;}
			motor[motorB]=0;}
	else {/* if it is on the second or third sweep, it was experimentally obtained to better to point at the top vertical
		coordinate due to the inaccuracy of the sonar sensor */
		 while (nMotorEncoder[motorB]<=y1){
			motor[motorB]=20;}
			motor[motorB]=0;}}


	void shoot_function (){/* to shoot the nerf gun. Written by Michael Lizewski */
		nMotorEncoder[motorC]=0;
		motor[motorC]=40;
		while (nMotorEncoder[motorC]<=360){}
		motor[motorC]=0;
		nMotorEncoder[motorC]=0;}



int sound_detector (){/* to detect specific sound of a goose that was chosen beforehand. Written by Siavash Gharehkhani  */
		if (SensorValue[S3]>=50){
		time10[T2]=0.0;
			while (time10[T2]<40){
				if (SensorValue[S3]>=60){
				return 0;}}
			while (time10[T2]<200){
				if (SensorValue[S3]>=50){
					return 1;}}
			}
	return 0;}


void x_reset () {/* to reset MotorA which is responsible for finding x coordinates. Written by Siavash Gharehkhani */
	motor[motorA] = -20;
	while (SensorValue[S2]==0){}/* once the horizontal sensor touch is pressed, stop the motor*/
	motor[motorA] =0;
	nMotorEncoder[motorA]=0;}

void y_reset () {/* to reset MotorB which is responsible for finding y coordinates. Written by Siavash Gharehkhani */
	motor[motorB] = -20;
	while (SensorValue[S1]==0){}/* once the vertical sensor touch is pressed, stop the motor*/
	motor[motorB] =0;
	nMotorEncoder[motorB]=0;}


task main()
{
SensorType[S2]= sensorTouch;
SensorType[S1]= sensorTouch;
SensorType[S3]= sensorSoundDB;
SensorType[S4]= sensorSONAR;

	time10[T1] =0; /* settign the timer to zero because its initial value is unknown */
	int sweep=0, x1=0, x2=0, shoot_counter=0, flag_Maxrotation=0, y2_encoder=0,/* initializing */
			y1=0, y2=0;
	float Dist=0;

	while (time10[T1]<12000 && shoot_counter<3){/* while 2 minutes hasn't passed and the robot hasn't made 3 shots */
		if (sound_detector()){/* If the sound sensor detected the sound of the goose and returned 1 */
				y_reset();/* just one y reset is needed no matter how many times the robot sweeps */
				sweep=0;
				while (sweep<3){/* while it hasnt made 3 sweeps */
					x_reset();/* it will reset everytime one full sweep has been made and nothing is found */
					x_finder (x1, x2, flag_Maxrotation, Dist);
					if (flag_Maxrotation==0) {/* flag indicating that it hasnt run out of its maximum rotational angle */
						x_center(x1,x2,Dist);
						y_finder(y1, y2, y2_encoder);
						y_center(y1, y2);
						shoot_function();
						shoot_counter++;/* add one to the number of shots made */
						sweep=3;/* in order to eaxit the loop to go back to goose sound search */
						}
					else {
					  if (sweep==0){
					  	while (nMotorEncoder[motorB]<=400){/* raise the angle from the horizon by 10 degrees which is equal to 400 degrees in encoder */
					  		motor[motorB]=40;}
					  	motor[motorB]=0;
					  	sweep++;}/* add one to the sweep level */
					  else if (sweep==1){/* if on the second sweep */
					  	while (nMotorEncoder[motorB]<=600){/* raise the angle from the horizon by another 10 degrees to 20 degrees overall  */
					  		motor[motorB]=40;}
					  	motor[motorB]=0;
					  	sweep++;}
					  else {/* if on the third sweep, just add to it so that it exits the loop at the top */
					  	sweep++;}
					  }
					  time10[T1]=0;/* set the timer to zero after one complete search and shoot  */
					  flag_Maxrotation=0;/* set the maximum rotation flag back to zero */
					  shoot_counter++;/* add one to the number of shots because even if it didn't find anything that still counts as a shot made  */
					  }
					}
				}
		}
